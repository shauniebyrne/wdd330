<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 10 Notes</title>
</head>
<body>
    <nav>
        <a href="../index.html">Home</a>  
        <a href="practice/fruit-start.html">Fruit Form</a>
        <a href="practice/driverslicense_form.html">Drivers License Form</a>
        <a href="practice/js_validation.html">JS Form Validation</a>
        <a href="practice/detailed_js_validation_form/index.html">Indepth JS Form Validation</a>
        <a href="teamassignment/index.html">Team Assignment</a>
    </nav>
   <h1>Week 10 Notes</h1>
   <h2>Please Note: I spent time on reading, practice assignments, the team assignment, and my main project this week. See samples above </h2> 
   <h3>MDN: Validating Forms</h3>
   <ul>
    <li>Client-side Form Validation: before submittin data to a server, it is important to ensure all required form controls are filled out, in the correct format</li>
    <li> :catches invalid data on the client-side so the user can easily fix the mistake without going to the server, waiting, and then getting an error message </li>
    <li> :validation done on in the browser</li>
    <li>**Still need to validate on server side because client-side is too easy to bypass</li>
    <li>Server-side Validation: validation done on the server</li>
    <li>Form Validation: error messages when forms are not filled out correctly (ex. required field, or your password must contain.....)</li>
    <li>2 different types of client-side validation: 1. built-in form validation (uses HTML form validation features), and 2. JavaScript validation (coded using JS).</li>
    <li>Simplest HTML validation feature is the "required" attribute (wont submit form until all fields that are required are filled out)</li>
    <li>WCAG accessiblity guidlines require a programmer to indicate to a suwer when form fields are required</li>
    <li>Pattern Attribute: expects a regular expression (regexps - a pattern that can be used to match character combinations in text strings) as its value</li>
    <li>"textarea" element doesn't support the "pattern" attribute</li>
    <li>**"input type="number or range or date"" can also take a "step" attribute that specifies what increment the value will go up or down by</li>
    <li>Constraint Validation API: consists of a set of methods and properties avaiable for form element DOM interfaces (such as button, fieldset, input, output, select, textarea)</li>
    <li>Why use Constraint Validation API: because regular HTML error codes you cant customize; using this you can customize error codes using JS</li>
    </ul>
       
    <h3>MDN: Using Fetch</h3>
    <ul>
        <li>A global fetch() method provides easy, logical ways to fetch resources asynchronously accross networks</li>
        <li>The fetch() method can optionally accept a second parameter, an init object that allows you to control a number of different settings (see fetch_practice.js for examples of these options)</li>
        <li>Can make a copy of request which is pretty useful because request and response bodies can only be used once</li>
        <li>clone() method creates a copy</li>
        <li>Both above forms of creating a copy will fail if the body of the original request or response has already been read</li>
        <li>Headers interface: allows you to create your own headers object via the Headers() constructor</li>
        <li>Headers Object: a simple multi-map of names to values</li>
        <li>A good way to use headers is to check whether the content type is correct before you process it further</li>
        <li>Because headers can be sent in requests and received in responses, and have limitations about what info can and should be mutable, header objects have a guard property</li>
        <li>Response instances are returned when fetch() promises are resolved (use Response.status, Response.statusText, or Response.ok)</li>
        <li>Both requests and responses may contain body data</li>
        <li>A body is an instance of any of these types: ArrayBuffer, TypedArray, DataView, Blob, File, String (string literal), URLSearchParams, and FormData</li>
        <li>Body example: fetch('/login', { method: 'POST', body: form });</li>
        <li>Fetch API support can be deteced by checking for the existence of Headres, Request, Response, or fetch() on the Window or Worker scope (ex. if (window.fetch) { run my fetch request here } else { do something with XMLHttpRequest?})</li>
    </ul>
       